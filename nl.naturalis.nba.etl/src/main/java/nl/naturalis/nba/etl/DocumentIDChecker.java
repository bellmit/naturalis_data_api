package nl.naturalis.nba.etl;

import static nl.naturalis.nba.etl.ETLUtil.logDuration;

import org.apache.logging.log4j.Logger;
import org.elasticsearch.index.IndexNotFoundException;

import nl.naturalis.nba.api.QueryCondition;
import nl.naturalis.nba.api.QuerySpec;
import nl.naturalis.nba.api.model.IDocumentObject;
import nl.naturalis.nba.dao.DocumentType;
import nl.naturalis.nba.dao.exception.DaoException;
import nl.naturalis.nba.dao.util.es.DirtyDocumentIterator;

/**
 * Checks if each document has an elasticsearch id containing an @ . If this is
 * true, a document has an id generated by nba; if not, the id will have been
 * generated by elasticsearch, which is unwanted and hence false.
 * 
 * @author Tom Gilissen
 *
 */
public class DocumentIDChecker {

	private static final Logger logger = ETLRegistry.getInstance().getLogger(DocumentIDChecker.class);
	private DocumentType<?> dt;

	
	public static void main(String[] args) throws Exception
	{
		for (DocumentType<?> dt : DocumentType.getAllDocumentTypes()) {
			try {
				DocumentIDChecker checker = new DocumentIDChecker(dt);
				checker.CheckIDs();
			}
			catch (IndexNotFoundException e) {
				logger.warn("There is no index for {} document.", dt.getName());
			}
			catch (DaoException e) {
				logger.warn("Query for retrieving {} documents is incorrect: {}", dt.getName(), e.getMessage());
			}
			finally {}
		}
	}

	
	public <T> DocumentIDChecker(DocumentType<?> dt)
	{
		this.dt = dt;
	}

	/**
	 * Runs an elasticsearch query to retrieve all documents of the specified
	 * DocumentType and then checks if the elasticsearch id of each document
	 * contains an "@" (meaning that this id has been created by the nba).
	 *  
	 * @throws Exception
	 */
	public void CheckIDs() throws Exception
	{
		long start = System.currentTimeMillis();
		int batchSize = 1000;
		int processed = 0;
		int errors = 0;
		String documentType = dt.getName();
		String field = "sourceSystemId";

		QuerySpec qs = new QuerySpec();
		qs.setConstantScore(true);
		qs.setSize(batchSize);
		qs.addCondition(new QueryCondition(field, "NOT_EQUALS", null));
		DirtyDocumentIterator<?> iterator = new DirtyDocumentIterator<>(dt, qs);
		
		logger.info("-----------------------------");
		logger.info("Processing {} documents", documentType);
		for (IDocumentObject document : iterator) {
			processed++;
			if (!document.getId().contains("@")) {
				errors++;
				logger.error("Found document with incorrect id: {}", document.getId());
			}
			if (processed % 100000 == 0) {
				logger.info("{} documents processed: {}", documentType, processed);
				logger.info("{} documents with incorrect ID: {}", documentType, errors);
			}
		}
		logger.info("{} documents processed: {}", documentType, processed);
		logger.info("Check finished with {} errors", errors);
		logDuration(logger, getClass(), start);
	}

}
