package nl.naturalis.nda.elasticsearch.dao.dao;

import nl.naturalis.nda.domain.ScientificName;
import nl.naturalis.nda.domain.Taxon;
import nl.naturalis.nda.search.Link;
import nl.naturalis.nda.search.QueryParams;
import nl.naturalis.nda.search.SearchResult;
import nl.naturalis.nda.search.SearchResultSet;
import org.elasticsearch.client.Client;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class BioportalTaxonDao extends AbstractTaxonDao {

    private static final Set<String> allowedFieldNamesForSearch = new HashSet<>(Arrays.asList(
            "acceptedName.genusOrMonomial",
            "acceptedName.subgenus",
            "acceptedName.specificEpithet",
            "acceptedName.infraspecificEpithet",
            "acceptedName.experts.fullName",
            "acceptedName.experts.organization.name",
            "acceptedName.taxonomicStatus",
            "vernacularNames.name",
            "vernacularNames.experts.fullName",
            "vernacularNames.experts.organization.name",
            "synonyms.scientificName.genusOrMonomial",
            "synonyms.subgenus",
            "synonyms.scientificName.specificEpithet",
            "synonyms.scientificName.infraspecificEpithet",
            "synonyms.scientificName.expert.fullName",
            "synonyms.scientificName.expert.organization.name",
            "synonyms.taxonomicStatus",
            "defaultClassification.kingdom",
            "defaultClassification.phylum",
            "defaultClassification.className",
            "defaultClassification.order",
            "defaultClassification.family",
            "defaultClassification.genus",
            "defaultClassification.subgenus",
            "defaultClassification. specificEpithet",
            "defaultClassification.infraspecificEpithet",
            "systemClassification.name",
            "experts.fullName"
    ));

    public BioportalTaxonDao(Client esClient, String ndaIndexName) {
        super(esClient, ndaIndexName);
    }

    /**
     * Retrieves taxa matching a variable number of criteria.
     *
     * @param params A {@link QueryParams} object containing:
     *               1. fields ... . A variable number of filters for fields. For example, the
     *               QueryParams object may contain a key “defaultClassification.genus” with a
     *               value of “Homo” and a key “defaultClassification.specificEpithet” with a
     *               value of “sapiens”. Fields must be mapped according to the mapping
     *               mechanism described above. Thus, if the QueryParams object contains a
     *               key “genus”, that key must be mapped to the “defaultClassification.genus”
     *               field.
     *               2. _andOr. An enumerated value with “AND” and “OR” as valid values. “AND”
     *               means all fields must match. “OR” means some fields must match. This is
     *               an optional parameter. By default only some fields must match. Will only
     *               be set if _source equals “Taxon_EXTENDED_NAME_SEARCH”. This value
     *               represents the DAO method whose query logic to re-execute.
     *               3. _sort. The field to sort on. Fields must be mapped according to the
     *               mapping mechanism described above. Special sort value: “_score” (sort by
     *               relevance). In practice sorting is only allowed on _score and on
     *               identifications.scientificName.fullScientificName. This is an optional
     *               parameter. By default sorting is done on _score.
     * @return search results
     */
    public SearchResultSet<Taxon> taxonSearch(QueryParams params) {
        return search(params, allowedFieldNamesForSearch);
    }

    /**
     * Retrieves Taxon documents by scientific name. Since the Taxon document type is populated from two source systems
     * (CoL and NSR), a search by scientific name may result in 0, 1 or at most 2 search results.
     * <p/>
     * A taxon retrieved through this method is always retrieved through a REST link in  the response from either
     * taxonSearch. This method is aware of the result set generated by those methods and is therefore capable of
     * generating REST links to the previous and next taxon in the result set. All parameters passed to taxonSearch
     * will also be passed to this method. Basically, this method has to re-execute the query executed by taxonSearch,
     * pick out the taxa with the specified accepted name, and generate REST links to the previous and next taxa
     * in the result set.
     *
     * @param params A {@link QueryParams} object
     * @return search result with previous and next link
     */
    public SearchResultSet<Taxon> getTaxonDetailWithinResultSet(QueryParams params) {
        SearchResultSet<Taxon> searchResultSet = taxonSearch(params);

        return createTaxonDetailSearchResultSet(params, searchResultSet);
    }

    protected SearchResultSet<Taxon> createTaxonDetailSearchResultSet(QueryParams params,
                                                                      SearchResultSet<Taxon> searchResultSet) {
        SearchResultSet<Taxon> detailResultSet = new SearchResultSet<>();

        SearchResult<Taxon> previousTaxon = null;
        SearchResult<Taxon> nextTaxon = null;

        String genusOrMonomial = params.getParam("acceptedName.genusOrMonomial");
        String specificEpithet = params.getParam("acceptedName.specificEpithet");
        String infraspecificEpithet = params.getParam("acceptedName.infraspecificEpithet");

        List<SearchResult<Taxon>> searchResults = searchResultSet.getSearchResults();
        for (SearchResult<Taxon> searchResult : searchResults) {
            ScientificName acceptedName = searchResult.getResult().getAcceptedName();
            if (acceptedName != null
                    && acceptedName.isSameScientificName(createScientificName(genusOrMonomial,
                                                                              specificEpithet,
                                                                              infraspecificEpithet))) {
                SearchResult<Taxon> result = new SearchResult<>();
                result.setResult(searchResult.getResult());
                int indexFoundTaxon = searchResults.indexOf(searchResult);
                int searchResultSize = searchResults.size();
                if (searchResultSize > 1) {
                    if (indexFoundTaxon == 0) {
                        // first item, no previous
                        nextTaxon = searchResults.get(1);
                    } else if (indexFoundTaxon == (searchResultSize - 1)) {
                        // last item, no next
                        previousTaxon = searchResults.get(indexFoundTaxon - 1);
                    } else {
                        nextTaxon = searchResults.get(indexFoundTaxon + 1);
                        previousTaxon = searchResults.get(indexFoundTaxon - 1);
                    }
                }

                //TODO Change links to correct url and href
                if (previousTaxon != null) {
                    result.addLink(new Link("http://test.nl?acceptedName=" + previousTaxon.getResult().getAcceptedName()
                            .getGenusOrMonomial(),
                            "_previous"));
                }
                if (nextTaxon != null) {
                    result.addLink(new Link("http://test.nl?acceptedName=" + nextTaxon.getResult().getAcceptedName()
                            .getGenusOrMonomial(), "_next"));
                }

                detailResultSet.addSearchResult(result);
            }
        }

        detailResultSet.setQueryParameters(params.copyWithoutGeoShape());
        return detailResultSet;
    }

    private ScientificName createScientificName(String genusOrMonomial, String specificEpithet,
                                                String infraspecificEpithet) {
        ScientificName scientificName = new ScientificName();
        scientificName.setGenusOrMonomial(genusOrMonomial);
        scientificName.setSpecificEpithet(specificEpithet);
        scientificName.setInfraspecificEpithet(infraspecificEpithet);
        return scientificName;
    }
}
